#!/usr/bin/env bash

#     Copyright 2002-2009 Maurizio Patrignani, Maurizio Pizzonia, Fabio Ricci,
#     Massimo Rimondini - Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This is the Netkit vlist script, which is used to list running virtual machines
# and/or ask for details about a given machine.

SCRIPTNAME=$(basename "$0")

if [ -z "$NETKIT_HOME" ]; then
   echo 1>&2 "$SCRIPTNAME: The NETKIT_HOME environment variable is not properly set;"
   echo 1>&2 "please set it as described in the Netkit documentation and try again."
   exit 1
fi

# shellcheck source=./lcommon
. "$NETKIT_HOME/bin/lcommon"
# shellcheck source=./script_utils
. "$NETKIT_HOME/bin/script_utils"

# Write to the vcommands log
log_write "$0 $*"


###############################################################################
# Write vlist's usage line to standard output.
# Usage:
#   usage_line
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
usage_line() {
   echo "Usage: $SCRIPTNAME [OPTION]... [MACHINE]..."
}


###############################################################################
# Write vlist's usage as a full dialog or a "try --help".
# Usage:
#   usage STATUS
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   $1 - status code to exit with. When zero, usage will write to standard
#        output and describe all options (for --help). Else, it will write to
#        standard error and be a brief usage and try-help message.
# Returns:
#   None - exits with a status code of STATUS
# Example:
#   None
###############################################################################
usage() {
   status=$1

   if [ "$status" -ne 0 ]; then
      usage_line 1>&2
      try_help
      exit "$status"
   fi

   cat << END_OF_HELP
$(usage_line)
List running Netkit virtual machines and get detailed information about
MACHINE(s).

  -n, --no-header     suppress header line and summary information in the
                        output
  -u, --user=USERNAME  show virtual machines owned by USERNAME. Using the
                        special user name '-' results in considering all users.
                        By default, only virtual machines for the current user
                        are shown

Miscellaneous:
$(help_option)
$(version_option)

By specifying one or more MACHINEs it is possible to get detailed information.
If --user=- is also being used, information about the first MACHINE with a
matching name in the output of 'vlist --user=-' is reported.

END_OF_HELP

   exit "$status"
}


# USERID is set in script_utils
USER="$USERID"


# Get command line options
LONG_OPTS="help,no-header,user:,version"
SHORT_OPTS="hnu:"

if ! GETOPT_OPTS=$(getopt --name "$SCRIPTNAME" --options "$SHORT_OPTS" --longoptions "$LONG_OPTS" -- "$@"); then
   # getopt will output the errorneous command-line argument
   usage 1
fi

# (Safely) set positional parameters to those reordered by getopt
eval set -- "$GETOPT_OPTS"

while true; do
   case "$1" in
      --help|-h)
         usage 0
         ;;
      --no-header|-n)
         no_header=true
         ;;
      --user|-u)
         USER="$2"
         [ "$USER" = "-" ] && unset USER
         shift
         ;;
      --version)
         showVersion
         exit 0
         ;;
      --)
         shift
         break
         ;;
      *)
         echo 1>&2 "$SCRIPTNAME: Unknown error parsing command line arguments"
         usage 1
         ;;
   esac

   shift
done

# Non-option arguments are machine names
vm_ids=( "$@" )

for host in "${vm_ids[@]}"; do
   checkSpaces "$host"
done


# Check whether -u - is being used together with a virtual machine ID
if [ -z "$USER" ] && [ "${#vm_ids[@]}" -ne 0 ]; then
   echo 1>&2 "$SCRIPTNAME: When giving VM names, a specific user ID must be provided"
   exit 1
fi


# Display summary of virtual machines
if [ "${#vm_ids[@]}" -eq 0 ]; then
   print_vm_summary "$no_header" "$USER"
fi


###############################################################################
# Summarise all running machines for a specific user.
# Usage:
#   print_vm_summary NO_HEADER USER
# Globals:
#   r- NETKIT_HOME
#   r- HUB_SOCKET_PREFIX
#   r- HUB_SOCKET_EXTENSION
# Arguments:
#   $1 - do not display column headers; pass an empty string to show them
#   $2 - user; pass an empty string for all users
# Returns:
#   None
# Example:
#   None
###############################################################################
print_vm_summary() {
   no_header=$1
   user=$2

   [ -n "$user" ] && pgrep_euid="--euid"

   # Column spacing:
   #   USER    20
   #   VHOST   20
   #   PID      5
   #   SIZE     9
   # A single space is added between each column, too (3 between SIZE and
   # INTERFACES).
   [ -z "$no_header" ] && echo "USER                 VHOST                  PID      SIZE   INTERFACES"

   # Iterate over the PIDs of running Netkit instances.
   # The process hierarchy (relevance of the PGID) is documented in
   # scripts_utils.
   machine_count=0
   for pid in $(pgrep ${pgrep_euid:+"$pgrep_euid"} ${user:+"$user"} --full "^$NETKIT_HOME/kernel/netkit-kernel"); do
      # Get the process group ID (PGID)
      pgid=$(ps --no-headers --format pgid --pid "$pid")

      # Ignore if not a process leader
      [ "$pgid" -ne "$pid" ] && continue

      machine_count=$((machine_count + 1))

      # Effective user ID of the process (full username if not too long)
      owner=$(ps --no-headers --format euser --pid "$pid")

      # Total virtual memory usage of the process.
      # Logically this should be the sum of every process in the group (PGID),
      # however in practice just taking the value of the parent process is
      # enough. The value should equate to roughly the size of the machine's
      # memory.
      memory_usage=$(ps --no-headers --format vsize --pid "$pid")
      total_memory_usage=$((total_memory_usage + memory_usage))

      # Full command used to invoke the process.
      # Why not parse the output of ps? Whitespace in the program name or
      # arguments is impossible to deal with. /proc/$pid/cmdline stores argv
      # with null-byte field separators, which is the only character that
      # cannot be present in a Linux filepath. This will still break if a
      # newline is present in the command, but if a user is doing that then
      # they are just asking for an error somewhere down the line to be honest.
      full_command=$(xargs -0 printf "%s\n" < "/proc/$pid/cmdline")

      first_iteration=true
      while IFS="" read -r argument; do
         # As per the manual, UML options are key=value pairs.
         # ${argument#*=} removes the key= prefix from argument (the single #
         # permits usage of further equals signs in the argument).
         # We skip the first argument (the program name)
         if $first_iteration; then
            first_iteration=false
         elif [[ "$argument" =~ ^umid=.*$ ]]; then
            umid=${argument#*=}
         elif [[ "$argument" =~ ^eth[0-9]+=.*$ ]]; then
            key=${argument%%=*}
            value=${argument#*=}

            # Interface number
            n=${key#eth}

            # UML socket filepath (assuming transport mode is daemon)
            uml_socket=${value#daemon,,,*}

            # Array of UML sockets indexed by the interface number
            uml_sockets[$n]=$uml_socket
            continue
         fi
      done <<< "$full_command"

      # No column will be truncated on a value that is too long
      printf "%-20s %-20s %5d %9d   " "$owner" "$umid" "$pid" "$memory_usage"

      first_iteration=true
      for i in "${!uml_sockets[@]}"; do
         filepath=${uml_sockets[$i]}
         filename=$(basename "$filepath")

         collision_domain_and_ext=${filename#"$HUB_SOCKET_PREFIX"_*_}
         collision_domain=${collision_domain_and_ext%"$HUB_SOCKET_EXTENSION"}

         # Comma-separate subsequent interfaces
         if $first_iteration; then
            first_iteration=false
         else
            echo -n ", "
         fi

         echo -n "eth$i @ $collision_domain"
      done

      echo
   done

   echo
   printf "Total virtual machines: %9d\n" "$machine_count"
   printf "Total consumed memory:  %9d KB\n" "$total_memory_usage"
}


###############################################################################
# Print complete information about a machine.
# Usage:
#   print_vm_info PID
# Globals:
#   r- NETKIT_HOME
#   r- VM_MEMORY_SKEW
# Arguments:
#   $1 - process ID (PID) of the machine
# Returns:
#   Prints machine details to stdout. Returns 0 on success, non-zero on
#   failure.
# Example:
#   None
###############################################################################
print_vm_info() {
   pid=$1

   # Effective user ID of the process (full username if not too long)
   owner=$(ps --no-headers --format euser --pid "$pid")

   # Total virtual memory usage of the process.
   # Logically this should be the sum of every process in the group (PGID),
   # however in practice just taking the value of the parent process is enough.
   # The value should equate to roughly the size of the machine's memory.
   memory_usage=$(ps --no-headers --format vsize --pid "$pid")

   # Full command used to invoke the process.
   # Why not parse the output of ps? Whitespace in the program name or
   # arguments is impossible to deal with. /proc/$pid/cmdline stores argv with
   # null-byte field separators, which is the only character that cannot be
   # present in a Linux filepath.
   # This will still break if a newline is present in the command, but if a
   # user is doing that then they are just asking for an error somewhere down
   # the line to be honest.
   full_command=$(xargs -0 printf "%s\n" < "/proc/$pid/cmdline")

   first_iteration=true
   while IFS="" read -r argument; do
      if $first_iteration; then
         program=$argument
         first_iteration=false
         continue
      fi

      # As per the manual, UML options are key=value pairs.
      # ${argument#*=} removes the key= prefix from argument (the single #
      # permits usage of further equals signs in the argument).

      # Edge-cases that can only be matched with regular expressions (or with
      # extglob enabled, which cannot be done.)
      if [[ "$argument" =~ ^eth[0-9]+=.*$ ]]; then
         key=${argument%%=*}
         value=${argument#*=}

         # Interface number
         n=${key#eth}

         # UML socket filepath (assuming transport mode is daemon)
         uml_socket=${value#daemon,,,*}

         # Array of UML sockets indexed by the interface number
         uml_sockets[$n]=$uml_socket
         continue
      fi

      # Most of the command-line options can be matched with basic pattern
      # matching:
      case "$argument" in
         umid=*)     umid=${argument#*=};;

         # Memory is NOT adjusted by the skew here
         mem=*)      mem=${argument#*=};;
         udb0=*)
            value=${argument#*=}

            # The udb0 value is disk,fs or fs
            disk=${value%%,*}
            fs=${value#*,}

            # The parameter expansions result in equal values if a single,
            # shared filesystem is used.
            [ "$disk" = "$fs" ] && unset disk
            ;;
         con0=* )
            value=${argument#*=}
            case "$value" in
               xterm)      con0=$value;;
               fd:0,fd:1)  con0="this";;
               pty)        con0=$value;;
               port:*)     con0=$value;;
               null)       con0="none";;
            esac
            ;;
         con1=*)
            value=${argument#*=}
            case "$value" in
               xterm)      con1=$value;;
               fd:0,fd:1)  con1="this";;
               pty)        con1=$value;;
               port:*)     con1=$value;;
               null)       con1="none";;
            esac
            ;;
         exec=*)     boot_cmd=${argument#*=};;
         hostlab=*)  hostlab=${argument#*=};;
         hostwd=*)   hostwd=${argument#*=};;
         hosthome=*) hosthome=${argument#*=};;
         modules=*)  modules=${argument#*=};;
         *)          other="$other $argument"
      esac
   done <<< "$full_command"

   # The UML console socket filepath
   mconsole=$MCONSOLE_DIR/$umid/mconsole

   # Output the machine details in a structured format
   echo "============= Information for virtual machine '$umid' ============="
   echo " --- Accounting information ---"
   echo "   PID:               $pid"
   echo "   Owner:             $owner"
   echo "   Used mem:          $memory_usage KB"
   echo " --- Emulation parameters ---"
   echo "   Kernel:            $program"
   echo "   Modules:           ${modules:-"-"}"
   echo "   Memory:            $((mem - VM_MEMORY_SKEW)) MB (+$VM_MEMORY_SKEW MB skew)"
   echo "   Model fs:          $fs"
   echo "   Filesystem:        ${disk:-"-"}"

   echo -n "   Interfaces:        "

   first_iteration=true
   for i in "${!uml_sockets[@]}"; do
      filepath=${uml_sockets[$i]}
      filename=$(basename "$filepath")

      collision_domain_and_ext=${filename#"$HUB_SOCKET_PREFIX"_*_}
      collision_domain=${collision_domain_and_ext%"$HUB_SOCKET_EXTENSION"}

      # Indent subsequent lines
      if $first_iteration; then
         first_iteration=false
      else
         echo -n "                      "
      fi

      echo "eth$i @ $collision_domain ($filepath)"
   done

   echo "   Hostlab:           ${hostlab:-"-"}"
   echo "   Hosthome:          ${hosthome:-"-"}"
   echo "   Working directory: ${hostwd:-"-"}"
   echo "   Boot command:      ${boot_cmd:-"-"}"

   echo -n "   Console 1:         "
   case "$con0" in
      none)    echo "disabled";;
      xterm)   echo "terminal emulator";;
      this)    echo "stdin/stdout";;
      pty)     echo "pty";;
      port:*)  echo "port ${con0#"port:"}"
   esac

   echo -n "   Console 2:         "
   case "$con1" in
      none)    echo "disabled";;
      xterm)   echo "terminal emulator";;
      this)    echo "stdin/stdout";;
      pty)     echo "pty";;
      port:*)  echo "port ${con1#"port:"}"
   esac

   echo "   Other arguments:   ${other:-"-"}"
   echo "   Console socket:    $mconsole"
}


# Get verbose information for specific virtual machines
for vm in "${vm_ids[@]}"; do
   if pid=$(get_vm_pid_by_name "$USER" "$vm"); then
      print_vm_info "$pid"
   else
      echo 1>&2 "$SCRIPTNAME: no virtual machine named '$vm' exists for $USER"
   fi
done
