#!/bin/bash

#     Copyright 2002-2009 Maurizio Patrignani, Maurizio Pizzonia, Fabio Ricci,
#     Massimo Rimondini - Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This is the Netkit vlist script, which is used to list running virtual machines
# and/or ask for details about a given machine.

SCRIPTNAME=$(basename "$0")

if [ -z "$NETKIT_HOME" ]; then
   echo 1>&2 "$SCRIPTNAME: The NETKIT_HOME environment variable is not properly set;"
   echo 1>&2 "please set it as described in the Netkit documentation and try again."
   exit 1
fi

# shellcheck source=./lcommon
. "$NETKIT_HOME/bin/lcommon"
# shellcheck source=./script_utils
. "$NETKIT_HOME/bin/script_utils"

# Write to the vcommands log
logWrite "$0 $*"


# This function is used to print the vlist usage
help() {
   echo
   echo "Usage: $SCRIPTNAME [OPTION]... MACHINE..."
   cat << END_OF_HELP
This script can be used to produce a list of running virtual machines. You can
use the following options to select the output contents:

  -h, --help          Show this help.
  -n, --no-header     Suppress header line and summary information in the
                      output.
  -u, --user=USERNAME Show virtual machines owned by USERNAME.
                      Using the special user name '-' results in considering
                      all users. By default, only virtual machines for the
                      current user are shown.
      --version       Print version information and exit.

By passing one or more MACHINE-IDs it is possible to get detailed information
about specific running virtual machines. MACHINE-ID is either a virtual machine 
name or its PID. If a virtual machine name is passed as argument, and the option
--user=- is being used, then information about the first machine with a matching
name in the output of 'vlist --user=-' are reported.
END_OF_HELP
}


# Output vlist's usage to stderr
# Usage: usage
usage() {
   echo 1>&2 "Usage: $SCRIPTNAME [OPTION]... MACHINE..."
   echo 1>&2 "Try '$SCRIPTNAME --help' for more information."
}


# USERID is set in script_utils
USER="$USERID"


# Get command line options
LONG_OPTS="help,no-header,user:,version"
SHORT_OPTS="hnu:"

if ! GETOPT_OPTS=$(getopt --name "$SCRIPTNAME" --options "$SHORT_OPTS" --longoptions "$LONG_OPTS" -- "$@"); then
   # getopt will output the errorneous command-line argument
   usage
   exit 1
fi

# (Safely) set positional parameters to those reordered by getopt
eval set -- "$GETOPT_OPTS"

while true; do
   case "$1" in
      --help|-h)
         help
         exit 0
         ;;
      --no-header|-n)
         NO_HEADER=1
         ;;
      --user|-u)
         USER="$2"
         [ "$USER" = "-" ] && unset USER
         shift
         ;;
      --version)
         showVersion
         exit 0
         ;;
      --)
         shift
         break
         ;;
      *)
         echo 1>&2 "$SCRIPTNAME: Unknown error parsing command line arguments"
         usage
         exit 1
         ;;
   esac

   shift
done

# Non-option arguments are machine names
VHOSTLIST=( "$@" )

for host in "${VHOSTLIST[@]}"; do
   checkSpaces "$host"
done


# Check whether -u - is being used together with a virtual machine ID
if [ -z "$USER" ] && [ -n "$VM_IDS" ]; then
   echo 1>&2 "$SCRIPTNAME: When giving VM names, a specific user ID must be provided"
   exit 1
fi


# Actually display list of virtual machines
if [ -z "$VM_IDS" ]; then
   showVMList "$NO_HEADER" "$USER"
fi

[ -n "$USER" ] && pgrep_euid="--euid"

# Iterate over the PIDs of running Netkit instances
for pid in $(pgrep "$pgrep_euid" "$USER" --full "^$NETKIT_HOME/kernel/netkit-kernel"); do
   # The process hierarchy looks like this:
   #
   #    PID  PGID  Process
   #     ?    ?     vstart
   #                    \
   #     x    x           - netkit-kernel
   #                           |
   #     a    x                +--- netkit-kernel
   #     b    x                +--- netkit-kernel
   #     c    x                +--- netkit-kernel
   #     ...  ...              +--- ...
   #
   #    (PID = process ID, PGID = process group ID)
   #
   # The main (parent) netkit-kernel process is the group leader of the
   # netkit-kernel child processes, because its PID == PGID.
   # The children are all part of this group.
   #
   # For vlist we only care about the parent kernel process, so we skip over
   # PIDs that are not group leaders.

   # Get the process group ID (PGID)
   pgid=$(ps --no-headers --format pgid --pid "$pid")

   # Ignore if not a process leader
   [ "$pgid" -ne "$pid" ] && continue

   # Effective user ID of the process (full username if not too long)
   owner=$(ps --no-headers --format euser --pid "$pid")

   # Total virtual memory usage of the process
   memory_usage=$(ps --no-headers --format vsize --pid "$pid")

   # Full command used to invoke the process.
   # Why not parse the output of ps? Whitespace in the program name or
   # arguments is impossible to deal with. /proc/$pid/cmdline stores argv with
   # null-byte field separators, which is the only character that cannot be
   # present in a Linux filepath.
   # This will still break if a newline is present in the command, but if a
   # user is doing that then they are just asking for an error somewhere down
   # the line to be honest.
   full_command=$(xargs -0 printf "%s\n" < "/proc/$pid/cmdline")

   first_iteration=true

   while IFS="" read -r argument; do
      if $first_iteration; then
         program=$argument
         first_iteration=false
         continue
      fi

      # As per the manual, UML options are key=value pairs.
      # ${argument#*=} removes the key= prefix from argument (the single #
      # permits usage of further equals signs in the argument).
      case "$argument" in
         umid=*)     umid="${argument#*=}";;
         mem=*)      mem="${argument#*=}";; # TODO: adjust by skew
         uml_dir=*)  uml_dir="${argument#*=}";;
         udb0=*)
            value="${argument#*=}"

            # udb0=disk,fs
            disk="${value%%,*}"
            fs="${value#*,}"
            ;;
         con0=* )
            value="${argument#*=}"
            case "$value" in
               xterm)      con0="$value";;
               fd:0,fd:1)  con0="this";;
               pty)        con0="$value";;
               port:*)     con0="$value";;
               null)       con0="none";;
            esac
            ;;
         con1=*)
            value="${argument#*=}"
            case "$value" in
               xterm)      con1="$value";;
               fd:0,fd:1)  con1="this";;
               pty)        con1="$value";;
               port:*)     con1="$value";;
               null)       con1="none";;
            esac
            ;;
         eth[0-9]+=*)
            key="${argument%%=*}"
            value="${argument#*=}"

            n="${key#eth}"

            # Array of collision domains indexed by the interface number
            interfaces[$n]="$value"
            ;;
         exec=*)     exec="${argument#*=}";;
         hostlab=*)  hostlab="${argument#*=}";;
         hostwd=*)   hostwd="${argument#*=}";;
         hosthome=*) hosthome="${argument#*=}";;
         modules=*)  modules="${argument#*=}";;
         *)          other="$other $argument"
      esac
   done <<< "$full_command"

   
done


# This function prints complete information about a virtual machine
printVMinfo() {
   echo
   echo "============= Information for virtual machine \"$VMINFO_NAME\" ============="
   echo " --- Accounting information ---"
   echo "   PID:        $VMINFO_PID"
   echo "   Owner:      $VMINFO_USER"
   echo "   Used mem:   $VMINFO_SIZE KB"
   echo " --- Emulation parameters ---"
   echo "   Kernel:     $VMINFO_KERNEL"
   [ ! -z "$VMINFO_KERNEL_MODULES" ] && echo "   Modules:    $VMINFO_KERNEL_MODULES"
   echo "   Memory:     ${VMINFO_MEM} MB"
   echo "   Model fs:   $VMINFO_SHAREDFS"
   echo -n "   Filesystem: "
   if [ "$VMINFO_FS" = "$VMINFO_SHAREDFS" ]; then
      echo "using model fs (no COW)"
   else
      echo "$VMINFO_FS"
   fi
   
   if [ ! -z "$VMINFO_ETH_INTERFACES" ]; then
      echo -n "   Interfaces: "
      echo "$VMINFO_ETH_INTERFACES" | awk -v RS=" +" -v FS="=" \
         '{
            if ($0 == "") {
               getline
               NR--
            }
            if (NR>1) printf "               "
            device = $1
            match ($2, "^[^_]+_[^_]+_[^_\\.]+\\..*")
            gsub("\n","",$2)
            hub_param_count = split(substr($2,RSTART,RLENGTH), hub_parameters, "[_.]")
            collision_domain = hub_parameters[hub_param_count-1]
            print device " @ " collision_domain "  (" $2 ")"
         }'
   fi
   [ ! -z "$VMINFO_HOSTHOME" ] && echo "   Hostfs at:  $VMINFO_HOSTHOME"
   [ ! -z "$VMINFO_EXEC" ] && echo "   Boot cmd:   $VMINFO_EXEC"
   [ ! -z "$VMINFO_HOSTLAB" ] && echo "   Hostlab at: $VMINFO_HOSTLAB"
   [ ! -z "$VMINFO_HOSTWD" ] && echo "   Host WD at: $VMINFO_HOSTWD"
   echo -n "   Console 1:  "
   case "$VMINFO_CON0" in
      NONE)    echo "disabled";;
      XTERM)   echo "terminal emulator";;
      THIS)    echo "stdin/stdout";;
      PTY)     echo "pty";;
      PORT:*)  echo "port ${VMINFO_CON0#PORT:}"
   esac
   echo -n "   Console 2:  "
   case "$VMINFO_CON1" in
      NONE)    echo "disabled";;
      XTERM)   echo "terminal emulator";;
      THIS)    echo "stdin/stdout";;
      PTY)     echo "pty";;
      PORT:*)  echo "port ${VMINFO_CON1#PORT:}"
   esac
   [ ! -z "$VMINFO_APPENDED" ] && echo "   Other args: $VMINFO_APPENDED"
   echo "   Mconsole:   $VMINFO_MCONSOLE"
   echo
}


# Get information for specific virtual machines
for VM in $VM_IDS; do
   if echo $VM | grep -qE "^[0-9]+$"; then
      # This is a virtual machine PID
      if ! getVMinfoByPID "$VM"; then
         echo 1>&2 "$SCRIPTNAME: no virtual machine having PID $VM exists."
      else
         printVMinfo
      fi
   else
      # This is a virtual machine name
      if ! getVMinfoByName "$USER" "$VM"; then
         echo 1>&2 "$SCRIPTNAME: no virtual machine named \"$VM\" exists for user $USER."
      else
         printVMinfo
      fi
   fi
done
