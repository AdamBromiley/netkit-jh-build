#!/bin/bash

#     Copyright 2002-2009 Maurizio Patrignani, Maurizio Pizzonia, Fabio Ricci,
#     Massimo Rimondini - Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This is the Netkit vhalt script, which is used to gracefully shut down a
# virtual machine.

SCRIPTNAME=$(basename "$0")

if [ -z "$NETKIT_HOME" ]; then
   echo 1>&2 "$SCRIPTNAME: The NETKIT_HOME environment variable is not properly set;"
   echo 1>&2 "please set it as described in the Netkit documentation and try again."
   exit 1
fi

# shellcheck source=./script_utils
. "$NETKIT_HOME/bin/script_utils"

# Write to the vcommands log
logWrite "$0 $*"


# This function is used to print the vhalt usage
help() {
   echo
   echo "Usage: $SCRIPTNAME [OPTION]... MACHINE..."
   cat << END_OF_HELP
Gracefully shutdown running MACHINE(s).

Available options are:

  -h, --help          Show this help.
  -q, --quick
      --quiet         Do not wait for virtual machines to shut down. Just issue
                      the halt command and exit. Using this option also
                      suppresses any output except errors and warnings.
  -r, --remove-fs     Delete virtual machine (COW) filesystem after halting
                      machine. Using this option has no effect on machines
                      started with the --no-cow option. Log files are not
                      removed.
  -u, --user=USERNAME Halt virtual machine(s) owned by user USERNAME. By using
                      the special user name '-' any virtual machine can be
                      halted, regardless of its owner (administrative privileges
                      are required).
      --version       Print version information and exit.             
END_OF_HELP
}


# Output vhalt's usage to stderr
# Usage: usage
usage() {
   echo 1>&2 "Usage: $SCRIPTNAME [OPTION]... MACHINE..."
   echo 1>&2 "Try '$SCRIPTNAME --help' for more information."
}


# USERID is set in script_utils
USER="$USERID"


# Get command line options
LONG_OPTS="help,quick,quiet,remove-fs,user:,version"
SHORT_OPTS="hqru:"

if ! GETOPT_OPTS=$(getopt --name "$SCRIPTNAME" --options "$SHORT_OPTS" --longoptions "$LONG_OPTS" -- "$@"); then
   # getopt will output the errorneous command-line argument
   usage
   exit 1
fi

# (Safely) set positional parameters to those reordered by getopt
eval set -- "$GETOPT_OPTS"

while true; do
   case "$1" in
      -h|--help)
         help
         exit 0
         ;;

      # TODO: Remove --quiet. Have --verbose and --quick (independent).
      -q|--quick|--quiet)
         BE_QUIET=1
         ;;
      --remove-fs|-r)
         REMOVE_FS=1
         ;;
      -u|--user)
         USER="$2"
         [ "$USER" = "-" ] && unset USER
         shift
         ;;
      --version)
         showVersion
         exit 0
         ;;
      --)
         shift
         break
         ;;
      *)
         echo 1>&2 "$SCRIPTNAME: Unknown error parsing command line arguments"
         usage
         exit 1
         ;;
   esac

   shift
done

# Non-option arguments are machine names
vm_hostnames=( "$@" )

for host in "${vm_hostnames[@]}"; do
   checkSpaces "$host"
done


# Check whether virtual machine name is missing
if [ "${#vm_hostnames[@]}" -eq 0 ]; then
   echo 1>&2 "$SCRIPTNAME: Missing virtual machine name"
   exit 1
fi


# Virtual machine filesystem cannot be removed in quiet mode because the
# machine may write files during shutdown
if [ -n "$REMOVE_FS" ] && [ -n "$BE_QUIET" ]; then
   echo 1>&2 "$SCRIPTNAME: Filesystem cannot be removed in quiet mode"
   exit 1
fi


# This function removes a virtual machine filesystem
remove_fs() {
   rm --verbose "$1"
}


for vm in "${vm_hostnames[@]}"; do
   if ! get_vm_info "$USER" "$vm"; then
      echo -n 1>&2 "$SCRIPTNAME: no virtual machine named '$vm' exists"
      [ -n "$USER" ] && echo " for user $USER." || echo "."
      exit 1
   fi

   [ -z "$BE_QUIET" ] && echo -e -n "Halting '$VMINFO_NAME' (PID $VMINFO_PID) owned by \
   $VMINFO_USER [                    ]\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"

   # Old method uses CTRL-ALT-DEL. This yields the error
   #   harddog_open - run_helper failed, errno = -2
   # and subsequently reboots (as opposed to powering off.)
   #"$NETKIT_HOME/bin/uml_mconsole" "$vm" cad > /dev/null

   # TODO: Try to use the old method - it uses /sbin/shutdown and is safer and
   # quicker.
   # New method uses the Magic SysRq key in the REISUO combination (R is not
   # included because there is no X server).
   # This method is not perfect; the timings required are rough estimates. The
   # system will return "OK" to uml_mconsole upon a valid command being sent,
   # NOT when the command has completed. e and i cannot be expected to finish
   # in the time given by the delay. s, u, and o are almost instant.

   # e: send a SIGTERM to all processes, except for init
   "$NETKIT_HOME/bin/uml_mconsole" "$vm" sysrq e > /dev/null
   sleep 2

   # i: send a SIGKILL to all processes, except for init
   "$NETKIT_HOME/bin/uml_mconsole" "$vm" sysrq i > /dev/null
   sleep 2

   # s: attempt to sync all mounted filesystems
   "$NETKIT_HOME/bin/uml_mconsole" "$vm" sysrq s > /dev/null
   sleep 0.2

   # u: attempt to remount all mounted filesystems read-only
   "$NETKIT_HOME/bin/uml_mconsole" "$vm" sysrq u > /dev/null
   sleep 0.2

   # o: shut the system off (if configured and supported)
   "$NETKIT_HOME/bin/uml_mconsole" "$vm" sysrq o > /dev/null

   if [ -z "$BE_QUIET" ]; then
      ATTEMPTS=1
      while get_vm_info "$USER" "$vm"; do
         sleep 1
         echo -n "."

         [ $ATTEMPTS -eq 20 ] && break
         ATTEMPTS=$((ATTEMPTS + 1))
      done

      echo

      # If machine is still up
      if get_vm_info "$USER" "$vm"; then
         echo 1>&2 "$SCRIPTNAME: could not shut down '$vm'."
      else
         if [ -n "$REMOVE_FS" ] && [ "$VMINFO_FS" != "$VMINFO_SHAREDFS" ]; then
            remove_fs "$VMINFO_FS"
         fi
      fi
   fi
done
