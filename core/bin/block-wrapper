#!/bin/bash

# This script essentially wraps around gnome/tmux commands and forces them to block.
# This is needed because gnome-terminal/tmux don't block until the command they're finishing has finished.
# Netkit relies on this to call the cleanHubs function, by trusting that the terminal/kernel command will block
# until the VM has ended. However, as gnome/tmux don't do this, the second they have booted the VMs, the hubs are 
# cleaned, causing a kernel panic.
#
# We also use this for all other terminal emulators, as it doesn't change their functionality. In the event that
# another terminal emulator suddenly swaps to non-blocking behaviour (as gnome did), they won't suddenly stop working.
#
# https://askubuntu.com/questions/627019/blocking-start-of-terminal


TERM_TYPE="$1"
shift;
VM_NAME="$1"
shift;
KERNELCMD="$*"


# The PID of the current terminal process is stored in a temporary file. This
# is so the program's state can be monitored later on for termination.
pidfile=$(mktemp)

sh_cmd="echo \$\$ > $pidfile; $KERNELCMD"

# PowerShell and cmd.exe requires escaping any semicolon in the Bash command to
# prevent unwanted interpretation.
# As an added quirk, the WSL invocation method does not require this escaping
# (presumably due to how the start command arguments are processed.)
ps_cmd="echo \$\$ > $pidfile\\; $KERNELCMD"


case "$TERM_TYPE" in
	konsole)       	konsole --nofork --title "$VM_NAME"                                     -e /bin/sh -c "$sh_cmd";;
	konsole-tab)   	"$NETKIT_HOME/bin/konsole-tabs.sh"                                      -e /bin/sh -c "$sh_cmd";;
	gnome)		 	gnome-terminal --title "$VM_NAME"                                       -- /bin/sh -c "$sh_cmd";;
	alacritty)	 	alacritty                                                               -e /bin/sh -c "$sh_cmd";;
	kitty)        	kitty --title "$VM_NAME"                                                   /bin/sh -c "$sh_cmd";;
    xterm)         	xterm -xrm 'XTerm*allowTitleOps: false' -T "$VM_NAME"                   -e /bin/sh -c "$sh_cmd";;
    wsl)            cmd.exe /c start wsl.exe                                                   /bin/sh -c "$sh_cmd";;
    wt)             cmd.exe /c wt.exe --suppressApplicationTitle --title "$VM_NAME" wsl.exe    /bin/sh -c "$ps_cmd";;
    tmux)
        tmux -L netkit has-session -t="$VM_NAME" 2>/dev/null
        if [ $? == 0 ]; then
            read -r -p "tmux session already exists for machine $VM_NAME. kill session? [y/N] " response
            case "$response" in
            [yY][eE][sS]|[yY]) 
                tmux -L netkit kill-session -t="$VM_NAME"
                ;;
            *)
                echo "tmux session in use - not starting $VM_NAME"
                exit
                ;;
            esac
        fi
        tmux -L netkit -f $NETKIT_HOME/tools/tmux.conf new -d -s $VM_NAME /bin/bash -c "echo \$$>$pidfile; $KERNELCMD"
        ;;

	*)
                    echo "Terminal $TERM_TYPE not supported, defaulting to xterm."
                    xterm -e /bin/bash -c "echo \$$>$pidfile; $KERNELCMD";;
esac


# Wait until $pidfile has been written to
until [ -s $pidfile ] 
    do sleep 1s
done

terminalpid=$(cat "$pidfile")
rm $pidfile

# Wait until this process is dead
while ps -p $terminalpid > /dev/null 2>&1; do
	sleep 1s
done
