#!/usr/bin/env bash

# This script essentially wraps around gnome/tmux commands and forces them to
# block. This is needed because gnome-terminal/tmux don't block until the
# command they're finishing has finished. Netkit relies on this to call the
# cleanHubs function, by trusting that the terminal/kernel command will block
# until the VM has ended. However, as gnome/tmux don't do this, the second they
# have booted the VMs, the hubs are cleaned, causing a kernel panic.
#
# We also use this for all other terminal emulators, as it doesn't change their
# functionality. In the event that another terminal emulator suddenly swaps to
# non-blocking behaviour (as gnome did), they won't suddenly stop working.
#
# https://askubuntu.com/questions/627019/blocking-start-of-terminal


TERM_TYPE="$1"
shift
VM_NAME="$1"
shift
KERNELCMD="$*"


# The PID of the current terminal process is stored in a temporary file. This
# is so the program's state can be monitored later on for termination.
pidfile=$(mktemp)

sh_cmd="echo \$\$ > $pidfile; $KERNELCMD"

# PowerShell and cmd.exe requires escaping any semicolon in the Bash command to
# prevent unwanted interpretation.
# As an added quirk, the WSL invocation method does not require this escaping
# (presumably due to how the start command arguments are processed.)
ps_cmd="echo \$\$ > $pidfile\\; $KERNELCMD"


case "$TERM_TYPE" in
    alacritty)      alacritty                                                               -e /bin/sh -c "$sh_cmd";;
    gnome)          gnome-terminal --title "$VM_NAME"                                       -- /bin/sh -c "$sh_cmd";;
    kitty)          kitty --title "$VM_NAME"                                                   /bin/sh -c "$sh_cmd";;
    konsole)        konsole --nofork --title "$VM_NAME"                                     -e /bin/sh -c "$sh_cmd";;
    konsole-tab)    "$NETKIT_HOME/bin/konsole-tabs.sh"                                      -e /bin/sh -c "$sh_cmd";;
    wsl)            cmd.exe /c start wsl.exe                                                   /bin/sh -c "$sh_cmd";;
    wt)             cmd.exe /c wt.exe --suppressApplicationTitle --title "$VM_NAME" wsl.exe    /bin/sh -c "$ps_cmd";;
    xterm)          xterm -xrm 'XTerm*allowTitleOps: false' -T "$VM_NAME"                   -e /bin/sh -c "$sh_cmd";;
    tmux)
        # Check if tmux session already exists
        if tmux -L netkit has-session -t "$VM_NAME" > /dev/null 2>&1; then
            while true; do
                read -rp "tmux session already exists for machine $VM_NAME. Kill session [y/N]? " response
                case "$response" in
                    [Yy]|[Yy][Ee][Ss] )
                        # Kill existing tmux session
                        tmux -L netkit kill-session -t "$VM_NAME"
                        break
                        ;;
                    [Nn]|[Nn][Oo] )
                        echo "tmux session in use - not starting $VM_NAME."
                        exit
                        ;;
                    *)
                        ;;
                esac
            done
        fi

        # Start detached tmux session
        tmux -L netkit -f "$NETKIT_HOME/tools/tmux.conf" new-session -d -s "$VM_NAME" /bin/sh -c "$sh_cmd"
        ;;

    *)
        echo "Terminal $TERM_TYPE not supported, defaulting to xterm."
        xterm -xrm 'XTerm*allowTitleOps: false' -T "$VM_NAME" -e /bin/sh -c "$sh_cmd";;
esac


# Wait until the PID file has been written to
until [ -s "$pidfile" ]; do
    sleep 1s
done

# Wait until this process is dead
while ps --pid "$(cat "$pidfile")" > /dev/null; do
    sleep 1s
done

rm "$pidfile"
